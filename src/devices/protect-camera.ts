/* Copyright(C) 2019-2024, HJD (https://github.com/hjdhjd). All rights reserved.
 *
 * protect-camera.ts: Camera device class for UniFi Protect.
 */
import { CharacteristicValue, PlatformAccessory, Resolution } from "homebridge";
import { ProtectCameraChannelConfig, ProtectCameraConfig, ProtectCameraConfigPayload, ProtectEventAdd, ProtectEventPacket } from "unifi-protect";
import { ProtectReservedNames, toCamelCase } from "../protect-types.js";
import { PROTECT_HOMEKIT_IDR_INTERVAL } from "../settings.js";
import { ProtectDevice } from "./protect-device.js";
import { ProtectNvr } from "../protect-nvr.js";
import { ProtectStreamingDelegate } from "../protect-stream.js";

export interface RtspEntry {

  channel: ProtectCameraChannelConfig,
  lens?: number,
  name: string,
  resolution: Resolution,
  url: string
}

export class ProtectCamera extends ProtectDevice {

  public hasHksv: boolean;
  private isDeleted: boolean;
  public isRinging: boolean;
  public detectLicensePlate: string[];
  private rtspEntries: RtspEntry[];
  private rtspQuality: { [index: string]: string };
  public stream!: ProtectStreamingDelegate;
  public ufp: ProtectCameraConfig;

  // Create an instance.
  constructor(nvr: ProtectNvr, device: ProtectCameraConfig, accessory: PlatformAccessory) {

    super(nvr, accessory);

    this.hasHksv = false;
    this.isDeleted = false;
    this.isRinging = false;
    this.detectLicensePlate = [];
    this.rtspEntries = [];
    this.rtspQuality = {};
    this.ufp = device;

    this.configureHints();
    void this.configureDevice();
  }

  // Configure device-specific settings for this device.
  protected configureHints(): boolean {

    // Configure our parent's hints.
    super.configureHints();

    this.hints.crop = this.hasFeature("Video.Crop");
    this.hints.hardwareDecoding = true;
    this.hints.hardwareTranscoding = this.hasFeature("Video.Transcode.Hardware");
    this.hints.highResSnapshots = this.hasFeature("Video.HighResSnapshots");
    this.hints.ledStatus = this.ufp.featureFlags.hasLedStatus && this.hasFeature("Device.StatusLed");
    this.hints.logDoorbell = this.hasFeature("Log.Doorbell");
    this.hints.logHksv = this.hasFeature("Log.HKSV");
    this.hints.probesize = 16384;
    this.hints.smartDetect = this.ufp.featureFlags.hasSmartDetect && this.hasFeature("Motion.SmartDetect");
    this.hints.timeshift = this.hasFeature("Video.HKSV.TimeshiftBuffer");
    this.hints.transcode = this.hasFeature("Video.Transcode");
    this.hints.transcodeHighLatency = this.hasFeature("Video.Transcode.HighLatency");
    this.hints.twoWayAudio = this.ufp.featureFlags.hasSpeaker && this.hasFeature("Audio") && this.hasFeature("Audio.TwoWay");

    return true;
  }

  // Configure a camera accessory for HomeKit.
  protected async configureDevice(): Promise<boolean> {

    // Save our context for reference before we recreate it.
    const savedContext = this.accessory.context;

    // Clean out the context object in case it's been polluted somehow.
    this.accessory.context = {};
    this.accessory.context.detectMotion = savedContext.detectMotion as boolean ?? true;
    this.accessory.context.dynamicBitrate = savedContext.dynamicBitrate as boolean ?? false;
    this.accessory.context.hksvRecording = savedContext.hksvRecording as boolean ?? true;
    this.accessory.context.mac = this.ufp.mac;
    this.accessory.context.nvr = this.nvr.ufp.mac;

    // Inform the user that motion detection will suck.
    if(this.ufp.recordingSettings.mode === "never") {

      this.log.info("WARNING: motion events will not be generated by the Protect controller when the controller's camera recording options are set to \"never\".");
    }

    // Inform the user if we have enabled the dynamic bitrate setting.
    if(this.hasFeature("Video.DynamicBitrate")) {

      this.log.info("Dynamic streaming bitrate adjustment on the UniFi Protect controller enabled.");
    }

    // Check to see if we have smart motion events enabled on a supported camera.
    if(this.hints.smartDetect) {

      // We deal with smart motion detection options here and save them on the ProtectCamera instance because we're trying to optimize the number of feature option
      // lookups we do in realtime, when possible. Reading a stream of constant events and having to perform a string comparison through a list of options multiple times
      // a second isn't an ideal use of CPU cycles, even if you have plenty of them to spare. Instead, we perform that lookup once, here, and set the appropriate option
      // booleans for faster lookup and use later in event detection.

      // Inform the user of what smart detection object types we're configured for.
      this.log.info("Smart motion detection enabled%s.", this.ufp.featureFlags.smartDetectTypes.length ?
        ": " + this.ufp.featureFlags.smartDetectTypes.sort().join(", ") : "");
    }

    // Configure accessory information.
    this.configureInfo();

    // Configure MQTT services.
    this.configureMqtt();

    // Configure the motion sensor.
    this.configureMotionSensor();

    // Configure smart motion contact sensors.
    this.configureMotionSmartSensor();

    // Configure the occupancy sensor.
    this.configureOccupancySensor();

    // Configure cropping.
    this.configureCrop();

    // Configure HomeKit Secure Video suport.
    this.configureHksv();
    this.configureHksvRecordingSwitch();

    // Configure our video stream.
    await this.configureVideoStream();

    // Configure our camera details.
    this.configureCameraDetails();

    // Configure our bitrate switch.
    this.configureDynamicBitrateSwitch();

    // Configure our NVR recording switches.
    this.configureNvrRecordingSwitch();

    // Configure the doorbell trigger.
    this.configureDoorbellTrigger();

    // Listen for events.
    this.nvr.events.on("updateEvent." + this.ufp.id, this.listeners["updateEvent." + this.ufp.id] = this.eventHandler.bind(this));

    if(this.hints.smartDetect) {

      this.nvr.events.on("addEvent." + this.ufp.id, this.listeners["addEvent." + this.ufp.id] = this.smartMotionEventHandler.bind(this));
    }

    return true;
  }

  // Cleanup after ourselves if we're being deleted.
  public cleanup(): void {

    // If we've got HomeKit Secure Video enabled and recording, disable it.
    if(this.stream?.hksv?.isRecording) {

      void this.stream.hksv.updateRecordingActive(false);
    }

    super.cleanup();

    this.isDeleted = true;
  }

  // Handle camera-related events.
  protected eventHandler(packet: ProtectEventPacket): void {

    const payload = packet.payload as ProtectCameraConfigPayload;

    // Process any RTSP stream updates.
    if(payload.channels) {

      void this.configureVideoStream();
    }

    // Process motion events.
    if(payload.lastMotion) {

      // We only want to process the motion event if we have the right payload, and either HKSV recording is enabled, or HKSV recording is disabled and we have
      // smart motion events disabled (or a device without smart motion capabilities) since those are handled elsewhere.
      if(this.stream?.hksv?.isRecording || (!this.stream?.hksv?.isRecording &&
        (!this.ufp.featureFlags.smartDetectTypes.length || (this.ufp.featureFlags.smartDetectTypes.length && !this.hints.smartDetect)))) {

        this.nvr.events.motionEventHandler(this);
      }
    }

    // Process ring events.
    if(payload.lastRing) {

      this.nvr.events.doorbellEventHandler(this, payload.lastRing);
    }

    // Process camera details updates:
    //   - availability state.
    //   - name change.
    //   - camera status light.
    //   - camera recording settings.
    if(payload.state || payload.name || payload.ledSettings?.isEnabled || payload.recordingSettings?.mode) {

      this.updateDevice();
    }
  }

  // Handle smart motion detection events.
  private smartMotionEventHandler(packet: ProtectEventPacket): void {

    const payload = packet.payload as ProtectEventAdd;

    // We're only interested in smart motion detection events.
    if((packet.header.modelKey !== "event") || !["smartDetectLine", "smartDetectZone"].includes(payload.type) || !payload.smartDetectTypes.length) {

      return;
    }

    // Process the motion event.
    this.nvr.events.motionEventHandler(this, payload.smartDetectTypes, payload.metadata);
  }

  // Configure discrete smart motion contact sensors for HomeKit.
  private configureMotionSmartSensor(): boolean {

    // Get any license plates the user has configured for detection, if any.
    this.detectLicensePlate = this.getFeatureValue("Motion.SmartDetect.ObjectSensors.LicensePlate")?.split("-").map(x => x.toUpperCase()) ?? [];

    // Check if we have disabled specific license plate smart motion object contact sensors, and if so, remove them.
    for(const objectService of this.accessory.services.filter(x => x.subtype?.startsWith(ProtectReservedNames.CONTACT_MOTION_SMARTDETECT_LICENSE + "."))) {

      // Do we have smart motion detection as well as license plate telemetry available to us and is this license plate configured? If so, move on.
      if(this.ufp.featureFlags.hasSmartDetect && this.ufp.featureFlags.smartDetectTypes.includes("licensePlate") && objectService.subtype &&
        this.detectLicensePlate.includes(objectService.subtype.slice(objectService.subtype.indexOf(".") + 1))) {

        continue;
      }

      // We don't have this contact sensor enabled, remove it.
      this.accessory.removeService(objectService);
      this.log.info("Disabling smart motion license plate contact sensor: %s.", objectService.subtype?.slice(objectService.subtype?.indexOf(".") + 1));
    }

    // If we don't have smart motion detection available or we have smart motion object contact sensors disabled, let's remove them.
    if(!this.ufp.featureFlags.hasSmartDetect || !this.hasFeature("Motion.SmartDetect.ObjectSensors")) {

      // Check for object-centric contact sensors that are no longer enabled and remove them.
      for(const objectService of this.accessory.services.filter(x => x.subtype?.startsWith(ProtectReservedNames.CONTACT_MOTION_SMARTDETECT + "."))) {

        // We don't have this contact sensor enabled, remove it.
        this.accessory.removeService(objectService);
        this.log.info("Disabling smart motion contact sensor: %s.", objectService.subtype?.slice(objectService.subtype?.indexOf(".") + 1));
      }
    }

    // If we don't have smart motion detection, we're done.
    if(!this.ufp.featureFlags.hasSmartDetect) {

      return false;
    }

    // A utility for us to add contact sensors.
    const addSmartDetectContactSensor = (name: string, serviceId: string, errorMessage: string): boolean => {

      // Acquire the service.
      const service = this.acquireService(this.hap.Service.ContactSensor, name, serviceId);

      // Fail gracefully.
      if(!service) {

        this.log.error(errorMessage);

        return false;
      }

      // Initialize the sensor.
      service.updateCharacteristic(this.hap.Characteristic.ContactSensorState, false);

      return true;
    };

    let enabledContactSensors = [];

    // Add individual contact sensors for each object detection type, if needed.
    if(this.hasFeature("Motion.SmartDetect.ObjectSensors")) {

      for(const smartDetectType of this.ufp.featureFlags.smartDetectTypes) {

        if(addSmartDetectContactSensor(this.accessoryName + " " + toCamelCase(smartDetectType),
          ProtectReservedNames.CONTACT_MOTION_SMARTDETECT + "." + smartDetectType, "Unable to add smart motion contact sensor for " + smartDetectType + " detection.")) {

          enabledContactSensors.push(smartDetectType);
        }
      }

      this.log.info("Smart motion contact sensor%s enabled: %s.", enabledContactSensors.length > 1 ? "s" : "", enabledContactSensors.join(", "));
    }

    enabledContactSensors = [];

    // Now process license plate contact sensors for individual detections.
    if(this.ufp.featureFlags.smartDetectTypes.includes("licensePlate")) {

      // Get the list of plates.
      for(const licenseOption of this.detectLicensePlate) {

        if(addSmartDetectContactSensor(this.accessoryName + " License Plate " + licenseOption,
          ProtectReservedNames.CONTACT_MOTION_SMARTDETECT_LICENSE + "." + licenseOption,
          "Unable to add smart motion license plate contact sensor for " + licenseOption + ".")) {

          enabledContactSensors.push(licenseOption);
        }
      }

      if(enabledContactSensors.length) {

        this.log.info("Smart motion license plate contact sensor%s enabled: %s.", enabledContactSensors.length > 1 ? "s" : "", enabledContactSensors.join(", "));
      }
    }

    return true;
  }

  // Configure a switch to manually trigger a doorbell ring event for HomeKit.
  private configureDoorbellTrigger(): boolean {

    // See if we have a doorbell service configured.
    let doorbellService = this.accessory.getService(this.hap.Service.Doorbell);

    // Validate whether we should have this service enabled.
    if(!this.validService(this.hap.Service.Switch, () => {

      // Doorbell switches are disabled by default and primarily exist for automation purposes.
      if(!this.hasFeature("Doorbell.Trigger")) {

        return false;
      }

      return true;
    }, ProtectReservedNames.SWITCH_DOORBELL_TRIGGER)) {

      // Since we aren't enabling the doorbell trigger on this camera, remove the doorbell service if the camera isn't actually doorbell-capable hardware.
      if(!this.ufp.featureFlags.isDoorbell && doorbellService) {

        this.accessory.removeService(doorbellService);
      }

      return false;
    }

    // We don't have a doorbell service configured, but since we've enabled a doorbell switch, we create the doorbell for automation purposes.
    if(!doorbellService) {

      // Configure the doorbell service.
      if(!this.configureVideoDoorbell()) {

        return false;
      }

      // Now find the doorbell service.
      if(!(doorbellService = this.accessory.getService(this.hap.Service.Doorbell))) {

        this.log.error("Unable to find the doorbell service.");
        return false;
      }
    }

    // Add the switch to the camera, if needed.
    const triggerService = this.acquireService(this.hap.Service.Switch, this.accessoryName + " Doorbell Trigger", ProtectReservedNames.SWITCH_DOORBELL_TRIGGER);

    // Fail gracefully.
    if(!triggerService) {

      this.log.error("Unable to add the doorbell trigger.");

      return false;
    }

    // Trigger the doorbell.
    triggerService.getCharacteristic(this.hap.Characteristic.On)?.onGet(() => {

      return this.isRinging;
    });

    triggerService.getCharacteristic(this.hap.Characteristic.On)?.onSet((value: CharacteristicValue) => {

      if(value) {

        // Trigger the ring event.
        this.nvr.events.doorbellEventHandler(this, Date.now());
        this.log.info("Doorbell ring event triggered.");

      } else {

        // If the doorbell ring event is still going, we should be as well.
        if(this.isRinging) {

          setTimeout(() => {
            triggerService?.updateCharacteristic(this.hap.Characteristic.On, true);
          }, 50);
        }
      }
    });

    // Initialize the switch.
    triggerService.updateCharacteristic(this.hap.Characteristic.On, false);

    this.log.info("Enabling doorbell automation trigger.");

    return true;
  }

  // Configure the doorbell service for HomeKit.
  protected configureVideoDoorbell(): boolean {

    // Acquire the service.
    const service = this.acquireService(this.hap.Service.Doorbell);

    // Fail gracefully.
    if(!service) {

      this.log.error("Unable to add doorbell.");

      return false;
    }

    // Add the doorbell service to this Protect doorbell. HomeKit requires the doorbell service to be marked as the primary service on the accessory.
    service.setPrimaryService(true);

    return true;
  }

  // Configure additional camera-specific characteristics for HomeKit.
  private configureCameraDetails(): boolean {

    // Find the service, if it exists.
    const statusLedService = this.accessory.getService(this.hap.Service.CameraOperatingMode);

    // Have we enabled the camera status LED?
    if(this.hints.ledStatus && statusLedService) {

      // Turn the status light on or off.
      statusLedService.getCharacteristic(this.hap.Characteristic.CameraOperatingModeIndicator)?.onGet(() => {

        return this.ufp.ledSettings?.isEnabled === true;
      });

      statusLedService.getCharacteristic(this.hap.Characteristic.CameraOperatingModeIndicator)?.onSet(async (value: CharacteristicValue) => {

        const ledState = value === true;

        // Update the status light in Protect.
        const newDevice = await this.nvr.ufpApi.updateDevice(this.ufp, { ledSettings: { isEnabled: ledState } });

        if(!newDevice) {

          this.log.error("Unable to turn the status light %s. Please ensure this username has the Administrator role in UniFi Protect.", ledState ? "on" : "off");
          return;
        }

        // Update our internal view of the device configuration.
        this.ufp = newDevice;
      });


      // Initialize the status light state.
      statusLedService.updateCharacteristic(this.hap.Characteristic.CameraOperatingModeIndicator, this.ufp.ledSettings.isEnabled === true);
    } else if(statusLedService) {

      // Remove the camera status light if we have it.
      const statusLight = statusLedService.getCharacteristic(this.hap.Characteristic.CameraOperatingModeIndicator);

      if(statusLight) {

        statusLedService.removeCharacteristic(statusLight);
      }
    }

    return true;
  }

  // Configure cropping characteristics.
  private configureCrop(): boolean {

    // We haven't enabled cropping.
    if(!this.hints.crop) {

      return true;
    }

    // Set our cropping parameters.
    this.hints.cropOptions = {

      height: this.getFeatureNumber("Video.Crop.Height") ?? 100,
      width: this.getFeatureNumber("Video.Crop.Width") ?? 100,
      x: this.getFeatureNumber("Video.Crop.X") ?? 0,
      y: this.getFeatureNumber("Video.Crop.Y") ?? 0
    };

    // Ensure we have sane values for our crop window.
    if((this.hints.cropOptions.height < 0) || (this.hints.cropOptions.height > 100)) {

      this.hints.cropOptions.height = 100;
    }

    if((this.hints.cropOptions.width < 0) || (this.hints.cropOptions.width > 100)) {

      this.hints.cropOptions.width = 100;
    }

    if((this.hints.cropOptions.x < 0) || (this.hints.cropOptions.x > 100)) {

      this.hints.cropOptions.x = 0;
    }

    if((this.hints.cropOptions.y < 0) || (this.hints.cropOptions.y > 100)) {

      this.hints.cropOptions.y = 0;
    }

    // Inform the user.
    this.log.info("Cropping the video stream to %sx%s% starting at %sx%s%.",
      this.hints.cropOptions.width, this.hints.cropOptions.height, this.hints.cropOptions.x, this.hints.cropOptions.y);

    // Transform our percentages into decimal form for FFmpeg.
    this.hints.cropOptions.height /= 100;
    this.hints.cropOptions.width /= 100;
    this.hints.cropOptions.x /= 100;
    this.hints.cropOptions.y /= 100;

    return true;
  }

  // Configure a camera accessory for HomeKit.
  private async configureVideoStream(): Promise<boolean> {

    const rtspEntries: RtspEntry[] = [];

    // No channels exist on this camera or we don't have access to the bootstrap configuration.
    if(!this.ufp.channels) {

      return false;
    }

    // Enable RTSP on the camera if needed and get the list of RTSP streams we have ultimately configured.
    this.ufp = await this.nvr.ufpApi.enableRtsp(this.ufp) ?? this.ufp;

    // Figure out which camera channels are RTSP-enabled, and user-enabled.
    let cameraChannels = this.ufp.channels.filter(x => x.isRtspEnabled && this.hasFeature("Video.Stream." + x.name, true));

    // Make sure we've got a HomeKit compatible IDR frame interval. If not, let's take care of that.
    const idrChannels = cameraChannels.filter(x => x.idrInterval !== PROTECT_HOMEKIT_IDR_INTERVAL);

    if(idrChannels.length) {

      // Edit the channel map and update the Protect controller.
      this.ufp = await this.nvr.ufpApi.updateDevice(this.ufp, { channels: idrChannels.map(x => Object.assign(x, { idrInterval: PROTECT_HOMEKIT_IDR_INTERVAL })) }) ??
        this.ufp;
    }

    // Set the camera and shapshot URLs.
    const cameraUrl = "rtsps://" + (this.nvr.config.overrideAddress ?? this.ufp.connectionHost) + ":" + this.nvr.ufp.ports.rtsps.toString() + "/";

    // Filter out any package camera entries. We deal with those independently in the package camera class.
    cameraChannels = cameraChannels.filter(x => x.name !== "Package Camera");

    // No RTSP streams are available that meet our criteria - we're done.
    if(!cameraChannels.length) {

      this.log.info("No RTSP stream profiles have been configured for this camera. " +
        "Enable at least one RTSP stream profile in the UniFi Protect webUI to resolve this issue or " +
        "assign the Administrator role to the user configured for this plugin to allow it to automatically configure itself."
      );

      return false;
    }

    // Now that we have our RTSP streams, create a list of supported resolutions for HomeKit.
    for(const channel of cameraChannels) {

      // Sanity check in case Protect reports nonsensical resolutions.
      if(!channel.name || (channel.width <= 0) || (channel.width > 65535) || (channel.height <= 0) || (channel.height > 65535)) {

        continue;
      }

      rtspEntries.push({

        channel: channel,
        name: this.getResolution([channel.width, channel.height, channel.fps]) + " (" + channel.name + ")",
        resolution: [ channel.width, channel.height, channel.fps ],
        url: cameraUrl + channel.rtspAlias + "?enableSrtp"
      });
    }

    // Sort the list of resolutions, from high to low.
    rtspEntries.sort(this.sortByResolutions.bind(this));

    let validResolutions = [];

    // Next, ensure we have mandatory resolutions required by HomeKit, as well as special support for Apple TV and Apple Watch, while respecting aspect ratios.
    // We use the frame rate of the first entry, which should be our highest resolution option that's native to the camera as the upper bound for frame rate.
    //
    // Our supported resolutions range from 4K through 320p.
    if((rtspEntries[0].resolution[0] / rtspEntries[0].resolution[1]) === (4 / 3)) {

      validResolutions = [

        [ 3840, 2880, 30 ], [ 2560, 1920, 30 ],
        [ 1920, 1440, 30 ], [ 1280, 960, 30 ],
        [ 640, 480, 30 ], [ 480, 360, 30 ],
        [ 320, 240, 30 ]
      ];
    } else {

      validResolutions = [

        [ 3840, 2160, 30 ], [ 2560, 1440, 30 ],
        [ 1920, 1080, 30], [ 1280, 720, 30 ],
        [ 640, 360, 30 ], [ 480, 270, 30 ],
        [ 320, 180, 30 ]
      ];
    }

    // Validate and add our entries to the list of what we make available to HomeKit. We map these resolutions to the channels we have available to us on the camera.
    for(const entry of validResolutions) {

      // This resolution is larger than the highest resolution on the camera, natively. We make an exception for 1080p and 720p resolutions since HomeKit explicitly
      // requires them.
      if((entry[0] >= rtspEntries[0].resolution[0]) && ![ 1920, 1280 ].includes(entry[0])) {

        continue;
      }

      // Find the closest RTSP match for this resolution.
      const foundRtsp = this.findRtsp(entry[0], entry[1], { rtspEntries: rtspEntries });

      if(!foundRtsp) {

        continue;
      }

      // We already have this resolution in our list.
      if(rtspEntries.some(x => (x.resolution[0] === entry[0]) && (x.resolution[1] === entry[1]) && (x.resolution[2] === foundRtsp.channel.fps))) {

        continue;
      }

      // Add the resolution to the list of supported resolutions, but use the selected camera channel's native frame rate.
      rtspEntries.push({ channel: foundRtsp.channel, name: foundRtsp.name, resolution: [ entry[0], entry[1], foundRtsp.channel.fps ], url: foundRtsp.url });

      // Since we added resolutions to the list, resort resolutions, from high to low.
      rtspEntries.sort(this.sortByResolutions.bind(this));
    }

    // Ensure we've got at least one entry that can be used for HomeKit Secure Video. Some Protect cameras (e.g. G3 Flex) don't have a native frame rate that maps to
    // HomeKit's specific requirements for event recording, so we ensure there's at least one. This doesn't directly affect which stream is used to actually record
    // something, but it does determine whether HomeKit even attempts to use the camera for HomeKit Secure Video.
    if(![15, 24, 30].includes(rtspEntries[0].resolution[2])) {

      // Iterate through the list of RTSP entries we're providing to HomeKit and ensure we have at least one that will meet HomeKit's requirements for frame rate.
      for(let i = 0; i < rtspEntries.length; i++) {

        // We're only interested in the first 1080p or 1440p entry.
        if((rtspEntries[i].resolution[0] !== 1920) || ![ 1080, 1440 ].includes(rtspEntries[i].resolution[1])) {

          continue;
        }

        // Determine the best frame rate to use that's closest to what HomeKit wants to see.
        if(rtspEntries[i].resolution[2] > 24) {

          rtspEntries[i].resolution[2] = 30;
        } else if(rtspEntries[i].resolution[2] > 15) {

          rtspEntries[i].resolution[2] = 24;
        } else {

          rtspEntries[i].resolution[2] = 15;
        }

        break;
      }
    }

    // Publish our updated list of supported resolutions and their URLs.
    this.rtspEntries = rtspEntries;

    // If we've already configured the HomeKit video streaming delegate, we're done here.
    if(this.stream) {

      return true;
    }

    // Inform users about our RTSP entry mapping, if we're debugging.
    if(this.hasFeature("Debug.Video.Startup")) {

      for(const entry of this.rtspEntries) {

        this.log.info("Mapping resolution: %s.", this.getResolution(entry.resolution) + " => " + entry.name);
      }
    }

    // Check for explicit RTSP profile preferences.
    for(const rtspProfile of [ "LOW", "MEDIUM", "HIGH" ]) {

      // Check to see if the user has requested a specific streaming profile for this camera.
      if(this.hasFeature("Video.Stream.Only." + rtspProfile)) {

        this.rtspQuality.StreamingDefault = rtspProfile;
      }

      // Check to see if the user has requested a specific recording profile for this camera.
      if(this.hasFeature("Video.HKSV.Record.Only." + rtspProfile)) {

        this.rtspQuality.RecordingDefault = rtspProfile;
      }
    }

    // Inform the user if we've set a streaming default.
    if(this.rtspQuality.StreamingDefault) {

      this.log.info("Video streaming configured to use only: %s.", toCamelCase(this.rtspQuality.StreamingDefault.toLowerCase()));
    }

    // Inform the user if they've selected the legacy snapshot API.
    if(!this.hints.highResSnapshots) {

      this.log.info("Disabling the use of higher quality snapshots.");
    }

    // Inform the user if we've set a recording default.
    if(this.rtspQuality.RecordingDefault) {

      this.log.info("HomeKit Secure Video event recording configured to use only: %s.", toCamelCase(this.rtspQuality.RecordingDefault.toLowerCase()));
    }

    // Configure the video stream with our resolutions.
    this.stream = new ProtectStreamingDelegate(this, this.rtspEntries.map(x => x.resolution));

    // Fire up the controller and inform HomeKit about it.
    this.accessory.configureController(this.stream.controller);

    return true;
  }

  // Configure HomeKit Secure Video support.
  private configureHksv(): boolean {

    this.hasHksv = true;

    // If we have smart motion events enabled, let's warn the user that things will not work quite the way they expect.
    if(this.hints.smartDetect) {

      this.log.info("WARNING: Smart motion detection and HomeKit Secure Video provide overlapping functionality. " +
        "Only HomeKit Secure Video, when event recording is enabled in the Home app, will be used to trigger motion event notifications for this camera." +
        (this.hasFeature("Motion.SmartDetect.ObjectSensors") ? " Smart motion contact sensors will continue to function using telemetry from UniFi Protect." : ""));
    }

    return true;
  }

  // Configure a switch to manually enable or disable HKSV recording for a camera.
  private configureHksvRecordingSwitch(): boolean {

    // Validate whether we should have this service enabled.
    if(!this.validService(this.hap.Service.Switch, () => {

      // If we don't have HKSV or the HKSV recording switch enabled, disable it and we're done.
      if(!this.hasFeature("Video.HKSV.Recording.Switch")) {

        return false;
      }

      return true;
    }, ProtectReservedNames.SWITCH_HKSV_RECORDING)) {

      // We want to default this back to recording whenever we disable the recording switch.
      this.accessory.context.hksvRecording = true;

      return false;
    }

    // Acquire the service.
    const service = this.acquireService(this.hap.Service.Switch, this.accessoryName + " HKSV Recording", ProtectReservedNames.SWITCH_HKSV_RECORDING);

    // Fail gracefully.
    if(!service) {

      this.log.error("Unable to add HKSV recording switch.");

      return false;
    }

    // Activate or deactivate HKSV recording.
    service.getCharacteristic(this.hap.Characteristic.On)?.onGet(() => {

      return this.accessory.context.hksvRecording as boolean ?? true;
    });

    service.getCharacteristic(this.hap.Characteristic.On)?.onSet((value: CharacteristicValue) => {

      if(this.accessory.context.hksvRecording !== value) {

        this.log.info("HKSV event recording has been %s.", value === true ? "enabled" : "disabled");
      }

      this.accessory.context.hksvRecording = value === true;
    });

    // Initialize the switch.
    service.updateCharacteristic(this.hap.Characteristic.On, this.accessory.context.hksvRecording as boolean);

    this.log.info("Enabling HKSV recording switch.");

    return true;
  }

  // Configure a switch to manually enable or disable dynamic bitrate capabilities for a camera.
  private configureDynamicBitrateSwitch(): boolean {

    // Validate whether we should have this service enabled.
    if(!this.validService(this.hap.Service.Switch, () => {

      // If we don't want a dynamic bitrate switch, disable it and we're done.
      if(!this.hasFeature("Video.DynamicBitrate.Switch")) {

        return false;
      }

      return true;
    }, ProtectReservedNames.SWITCH_DYNAMIC_BITRATE)) {

      // We want to default this back to off by default whenever we disable the dynamic bitrate switch.
      this.accessory.context.dynamicBitrate = false;

      return false;
    }

    // Acquire the service.
    const service = this.acquireService(this.hap.Service.Switch, this.accessoryName + " Dynamic Bitrate", ProtectReservedNames.SWITCH_DYNAMIC_BITRATE);

    // Fail gracefully.
    if(!service) {

      this.log.error("Unable to add dynamic bitrate switch.");

      return false;
    }

    // Activate or deactivate dynamic bitrate for this device.
    service.getCharacteristic(this.hap.Characteristic.On)?.onGet(() => {

      return this.accessory.context.dynamicBitrate as boolean ?? false;
    });

    service.getCharacteristic(this.hap.Characteristic.On)?.onSet(async (value: CharacteristicValue) => {

      if(this.accessory.context.dynamicBitrate === value) {

        return;
      }

      // We're enabling dynamic bitrate for this device.
      if(value) {

        this.accessory.context.dynamicBitrate = true;
        this.log.info("Dynamic streaming bitrate adjustment on the UniFi Protect controller enabled.");

        return;
      }

      // We're disabling dynamic bitrate for this device. Update the channels JSON to revert to the maximum bitrate we can.
      const updatedChannels = this.ufp.channels.map(channel => ({ ...channel, bitrate: channel.maxBitrate }));

      // Send the channels JSON to Protect.
      const newDevice = await this.nvr.ufpApi.updateDevice(this.ufp, { channels: updatedChannels });

      // We failed.
      if(!newDevice) {

        this.log.error("Unable to set the streaming bitrate to %s.", value);
      } else {

        this.ufp = newDevice;
      }

      this.accessory.context.dynamicBitrate = false;
      this.log.info("Dynamic streaming bitrate adjustment on the UniFi Protect controller disabled.");
    });

    // Initialize the switch.
    service.updateCharacteristic(this.hap.Characteristic.On, this.accessory.context.dynamicBitrate as boolean);

    this.log.info("Enabling the dynamic streaming bitrate adjustment switch.");

    return true;
  }

  // Configure a series of switches to manually enable or disable recording on the UniFi Protect controller for a camera.
  private configureNvrRecordingSwitch(): boolean {

    const switchesEnabled = [];

    // The Protect controller supports three modes for recording on a camera: always, detections, and never. We create switches for each of the modes.
    for(const ufpRecordingSwitchType of
      [  ProtectReservedNames.SWITCH_UFP_RECORDING_ALWAYS, ProtectReservedNames.SWITCH_UFP_RECORDING_DETECTIONS, ProtectReservedNames.SWITCH_UFP_RECORDING_NEVER ]) {

      const ufpRecordingSetting = ufpRecordingSwitchType.slice(ufpRecordingSwitchType.lastIndexOf(".") + 1);

      // Validate whether we should have this service enabled.
      if(!this.validService(this.hap.Service.Switch, () => {

        // If we don't have the feature option enabled, disable the switch and we're done.
        if(!this.hasFeature("Nvr.Recording.Switch")) {

          return false;
        }

        return true;
      }, ufpRecordingSwitchType)) {

        continue;
      }

      const switchName = this.accessoryName + " UFP Recording " + toCamelCase(ufpRecordingSetting);

      // Acquire the service.
      const service = this.acquireService(this.hap.Service.Switch, switchName, ufpRecordingSwitchType);

      // Fail gracefully.
      if(!service) {

        this.log.error("Unable to add UniFi Protect recording switches.");

        continue;
      }

      // Activate or deactivate the appropriate recording mode on the Protect controller.
      service.getCharacteristic(this.hap.Characteristic.On)?.onGet(() => {

        return this.ufp.recordingSettings.mode === ufpRecordingSetting;
      });

      service.getCharacteristic(this.hap.Characteristic.On)?.onSet(async (value: CharacteristicValue) => {

        // We only want to do something if we're being activated. Turning off the switch would really be an undefined state given that there are three different
        // settings one can choose from. Instead, we do nothing and leave it to the user to choose what state they really want to set.
        if(!value) {

          setTimeout(() => {

            this.updateDevice();
          }, 50);

          return;
        }

        // Set our recording mode.
        this.ufp.recordingSettings.mode = ufpRecordingSetting;

        // Tell Protect about it.
        const newDevice = await this.nvr.ufpApi.updateDevice(this.ufp, { recordingSettings: this.ufp.recordingSettings });

        if(!newDevice) {

          this.log.error("Unable to set the UniFi Protect recording mode to %s.", ufpRecordingSetting);

          return false;
        }

        // Save our updated device context.
        this.ufp = newDevice;

        // Update all the other recording switches.
        for(const otherUfpSwitch of
          [ ProtectReservedNames.SWITCH_UFP_RECORDING_ALWAYS, ProtectReservedNames.SWITCH_UFP_RECORDING_DETECTIONS, ProtectReservedNames.SWITCH_UFP_RECORDING_NEVER ]) {

          // Don't update ourselves a second time.
          if(ufpRecordingSwitchType === otherUfpSwitch) {

            continue;
          }

          // Update the other recording switches.
          this.accessory.getServiceById(this.hap.Service.Switch, otherUfpSwitch)?.updateCharacteristic(this.hap.Characteristic.On, false);
        }

        // Inform the user, and we're done.
        this.log.info("UniFi Protect recording mode set to %s.", ufpRecordingSetting);
      });

      // Initialize the recording switch state.
      service.updateCharacteristic(this.hap.Characteristic.On, this.ufp.recordingSettings.mode === ufpRecordingSetting);
      switchesEnabled.push(ufpRecordingSetting);
    }

    if(switchesEnabled.length) {

      this.log.info("Enabling UniFi Protect recording switches: %s.", switchesEnabled.join(", "));
    }

    return true;
  }

  // Configure MQTT capabilities of this camera.
  protected configureMqtt(): boolean {

    // Return the RTSP URLs when requested.
    this.subscribeGet("rtsp", "RTSP information", (): string => {

      // Grab all the available RTSP channels and return them as a JSON.
      return JSON.stringify(Object.assign({}, ...this.ufp.channels.filter(channel => channel.isRtspEnabled)
        .map(channel => ({ [channel.name]: "rtsps://" + this.nvr.ufp.host + ":" + this.nvr.ufp.ports.rtsp + "/" + channel.rtspAlias + "?enableSrtp" }))));
    });

    // Trigger snapshots when requested.
    this.subscribeSet("snapshot", "snapshot trigger", (value: string) => {

      // When we get the right message, we trigger the snapshot request.
      if(value !== "true") {

        return;
      }

      void this.stream?.handleSnapshotRequest();
    });

    // Enable doorbell-specific MQTT capabilities only when we have a Protect doorbell or a doorbell trigger enabled.
    if(this.ufp.featureFlags.isDoorbell || this.hasFeature("Doorbell.Trigger")) {

      // Trigger doorbell when requested.
      this.subscribeSet("doorbell", "doorbell ring trigger", (value: string) => {

        // When we get the right message, we trigger the doorbell request.
        if(value !== "true") {

          return;
        }

        this.nvr.events.doorbellEventHandler(this, Date.now());
      });
    }

    return true;
  }

  // Refresh camera-specific characteristics.
  public updateDevice(): boolean {

    // Update the camera state.
    this.accessory.getService(this.hap.Service.MotionSensor)?.updateCharacteristic(this.hap.Characteristic.StatusActive, this.isOnline);

    // Check to see if this device has a status light.
    if(this.hints.ledStatus) {

      this.accessory.getService(this.hap.Service.CameraOperatingMode)?.
        updateCharacteristic(this.hap.Characteristic.CameraOperatingModeIndicator, this.ufp.ledSettings.isEnabled === true);
    }

    // Check for updates to the recording state, if we have the switches configured.
    if(this.hasFeature("Nvr.Recording.Switch")) {

      // Update all the switch states.
      for(const ufpRecordingSwitchType of
        [  ProtectReservedNames.SWITCH_UFP_RECORDING_ALWAYS, ProtectReservedNames.SWITCH_UFP_RECORDING_DETECTIONS, ProtectReservedNames.SWITCH_UFP_RECORDING_NEVER ]) {

        const ufpRecordingSetting = ufpRecordingSwitchType.slice(ufpRecordingSwitchType.lastIndexOf(".") + 1);

        // Update state based on the recording mode.
        this.accessory.getServiceById(this.hap.Service.Switch, ufpRecordingSwitchType)?.
          updateCharacteristic(this.hap.Characteristic.On, ufpRecordingSetting === this.ufp.recordingSettings.mode);
      }
    }

    return true;
  }

  // Get the current bitrate for a specific camera channel.
  public getBitrate(channelId: number): number {

    // Find the right channel.
    const channel = this.ufp.channels.find(x => x.id === channelId);

    return channel?.bitrate ?? -1;
  }

  // Set the bitrate for a specific camera channel.
  public async setBitrate(channelId: number, value: number): Promise<boolean> {

    // If we've disabled the ability to set the bitrate dynamically, silently fail. We prioritize switches over the global setting here, in case the user enabled both,
    // using the principle that the most specific setting always wins. If the user has both the global setting and the switch enabled, the switch will take precedence.
    if((!this.accessory.context.dynamicBitrate && !this.hasFeature("Video.DynamicBitrate")) ||
      (!this.accessory.context.dynamicBitrate && this.hasFeature("Video.DynamicBitrate") && this.hasFeature("Video.DynamicBitrate.Switch"))) {

      return true;
    }

    // Find the right channel.
    const channel = this.ufp.channels.find(x => x.id === channelId);

    // No channel, we're done.
    if(!channel) {

      return false;
    }

    // If our correct bitrate is already set, we're done.
    if(channel.bitrate === value) {

      return true;
    }

    // Make sure the requested bitrate fits within the constraints of what this channel can do.
    channel.bitrate = Math.min(channel.maxBitrate, Math.max(channel.minBitrate, value));

    // Tell Protect about it.
    const newDevice = await this.nvr.ufpApi.updateDevice(this.ufp, { channels: this.ufp.channels });

    if(!newDevice) {

      this.log.error("Unable to set the streaming bitrate to %s.", value);
      return false;
    }

    // Save our updated device context.
    this.ufp = newDevice;

    return true;
  }

  // Find an RTSP configuration for a given target resolution.
  private findRtspEntry(width: number, height: number, options?: { biasHigher?: boolean, default?: string, rtspEntries?: RtspEntry[] }): RtspEntry | null {

    const rtspEntries = options?.rtspEntries ?? this.rtspEntries;

    // No RTSP entries to choose from, we're done.
    if(!rtspEntries || !rtspEntries.length) {

      return null;
    }

    // Second, we check to see if we've set an explicit preference for stream quality.
    if(options?.default) {

      options.default = options.default.toUpperCase();

      return rtspEntries.find(x => x.channel.name.toUpperCase() === options.default) ?? null;
    }

    // See if we have a match for our desired resolution on the camera. We ignore FPS - HomeKit clients seem to be able to handle it just fine.
    const exactRtsp = rtspEntries.find(x => (x.channel.width === width) && (x.channel.height === height));

    if(exactRtsp) {

      return exactRtsp;
    }

    // If we haven't found an exact match, by default, we bias ourselves to the next lower resolution we find or the lowest resolution we have available as a backstop.
    if(!options?.biasHigher) {

      return rtspEntries.find(x => x.channel.width < width) ?? rtspEntries[rtspEntries.length - 1];
    }

    // If we're biasing ourselves toward higher resolutions (primarily used when transcoding so we start with a higher quality input), we look for the first entry that's
    // larger than our requested width and if not found, we return the highest resolution we have available.
    return rtspEntries.filter(x => x.channel.width > width).pop() ?? rtspEntries[0];
  }

  // Find a streaming RTSP configuration for a given target resolution.
  public findRtsp(width: number, height: number, options?: { biasHigher?: boolean, maxPixels?: number, rtspEntries?: RtspEntry[] }): RtspEntry | null {

    // Create our options JSON if needed.
    options = options ?? {};

    // See if we've been given RTSP entries or whether we should default to our own.
    options.rtspEntries = options.rtspEntries ?? this.rtspEntries;

    // If we've imposed a constraint on the maximum dimensions of what we want due to a hardware limitation, filter out those entries.
    if(options.maxPixels !== undefined) {

      options.rtspEntries = options.rtspEntries.filter(x => (x.channel.width * x.channel.height) <= (options.maxPixels ?? Infinity));
    }

    // Return the entry.
    return this.findRtspEntry(width, height, options);
  }

  // Find a recording RTSP configuration for a given target resolution.
  public findRecordingRtsp(width: number, height: number): RtspEntry | null {

    return this.findRtspEntry(width, height, { biasHigher: true, default: this.rtspQuality.RecordingDefault ?? this.stream.ffmpegOptions.recordingDefaultChannel });
  }

  // Utility function for sorting by resolution.
  private sortByResolutions(a: RtspEntry, b: RtspEntry): number {

    // Check width.
    if(a.resolution[0] < b.resolution[0]) {

      return 1;
    }

    if(a.resolution[0] > b.resolution[0]) {

      return -1;
    }

    // Check height.
    if(a.resolution[1] < b.resolution[1]) {

      return 1;
    }

    if(a.resolution[1] > b.resolution[1]) {

      return -1;
    }

    // Check FPS.
    if(a.resolution[2] < b.resolution[2]) {

      return 1;
    }

    if(a.resolution[2] > b.resolution[2]) {

      return -1;
    }

    return 0;
  }

  // Utility function to format resolution entries.
  protected getResolution(resolution: Resolution): string {

    return resolution[0].toString() + "x" + resolution[1].toString() + "@" + resolution[2].toString() + "fps";
  }
}
